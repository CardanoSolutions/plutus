\subsection{Values in Plutus Core}
\label{sec:uplc-values}
The semantics of
built-in functions in Plutus Core are obtained by instantiating the sets
$\Con{tn}$ of constants of type $tn$ (see Section~\ref{sec:builtin-inputs})
to be the expressions of the form \texttt{(con} $tn$ $c$\texttt{)} and the set
$\Inputs$ to be the set of Plutus Core
\textit{values}, terms which cannot immediately undergo any further reduction,
such as lambda terms and delayed terms.
Values also include partial applications of built-in functions such as
\texttt{[(builtin modInteger) (con integer 5)]}, which cannot perform any
computation until a second integer argument is supplied.  However, partial
applications must also be \textit{well-formed}: for example, applications of
\texttt{force} must be correctly interleaved with genuine arguments, and the
arguments must (a) themselves be values, and (2) must be of the types expected
by the function, so if \texttt{modInteger} has signature $\mathtt{[integer,
    integer]} \rightarrow \mathtt{integer}$ then \texttt{[(builtin modInteger)
    (con string "green")]} is illegal.
%
The occurrence of partially-applied builtins complicates the definition of
general values considerably.

We define syntactic classes $V$ of Plutus Core values and $P$ of partial builtin
applications simultaneously:

\begin{minipage}{\linewidth}
    \centering
    \[\begin{array}{lrcl}
        \textrm{Value}  & V   & ::= & \con{tn}{c} \\
                        &     &     & \delay{M} \\
                        &     &     & \lamU{x}{M} \\
                        &     &     & A
    \end{array}\]
    \captionof{figure}{Values in Plutus Core}
    \label{fig:untyped-cek-values}
\end{minipage}

\medskip
\noindent Here $A$ is the class of well-formed partial applications, and to define
this we first define a class of possibly ill-formed iterated applications for
each built-in function $b \in \Fun$:

\begin{minipage}{\linewidth}
    \centering
  \[\begin{array}{lrl}
  P & ::= & \builtin{b}\\
    &     & \appU{P}{V}\\
    &    & \force{P}\\
    \end{array}\]
    \captionof{figure}{Partial built-in function application}
    \label{fig:partial-applications}
\end{minipage}

\medskip
\noindent We let $\textsf{P}$ denote the set of terms generated by the grammar
in Figure~\ref{fig:partial-applications} and 
we define a function $\beta$ which extracts the name of the built-in
function occurring in a term in $\textsf{P}$:
$$
 \begin{array}{ll}
 \beta(\builtin{b}) &= b\\
 \beta(\appU{P}{V}) & =\beta(P)\\
 \beta({\force{P}}) & =\beta(P)\\
\end{array}
$$


%% $$
%% \begin{array}{ll}
%%   \sat{\builtin{b}} &= []\\
%%   \sat{\appU{P}{V}} &= \sat{P}\snoc\type(V)\\
%%   \sat{\force{P}}   &= \sat{P}\snoc\fforce\\
%% \end{array}
%% $$

\noindent We also define a function $\length$ which measures the size of a term $P \in \textsf{P}$:
$$
\begin{array}{ll}
\length(\texttt{(builtin $b$)}) &= 0\\
\length(\texttt{[$P$ $V$]}) &= 1+\length(P)\\
\length(\texttt{(force $P$)}) & = 1+\length(P)
\end{array}
$$


%% \item Our built-in functions can take general members of $\Inputs$ as arguments
%%   as well as elements of the sets $\denote{\tn}$ and the symbol $\top$ is used
%%   to denote the type of elements of $\Inputs$. We use the symbol $\top$
%%   (which we assume does not appear in any other set we mention) to denote the
%%   type of non-constant elements of $\Inputs$ and write $\UniTop = \Uni \disj
%%   \{\top\}$ and $\UnihatTop = \Unihat \disj \{\top\}$.
%% \item We should be able to examine inputs (even during execution) to determine
%%   their types.  More precisely we assume that there is a function $\type:
%%   \Inputs \rightarrow \UniTop$ such that
%%   $$\type(x) =
%%   \begin{cases}
%%     \tn &\ \mbox{if } x \in \Con{tn} \mbox{ for some } tn \in \Uni\\
%%     \top &\mbox{otherwise}
%%   \end{cases}
%%   $$
%%   \noindent This is well defined because of our assumption that the sets $\Con{tn}$ are disjoint.
%% \item We also define a partial order $\preceq$  on the set $\Uni^{\top}$ by
%%   $t_1 \preceq t_2$ if $t_1 = t_2$ or $t_2 = \top$.   


\paragraph{Well-formed iterated applications.} A term $P \in \textsf{P}$ is
an application of $b = \beta(P)$ to a number of values in $S$, interleaved with
applications of $\texttt{force}$.  We now define what it means for $P$ to be
\textit{well-formed}.  Firstly we let $n = \left|b\right| $ and we require that
$l \leq n$, so that $b$ is not over-applied.  In this case we put
$\iota=\iota_l$, the element of $b$'s signature which describes what kind of
``argument'' $b$ currently expects.  We complete the definition by induction on
the structure of $P$:
\begin{enumerate}
\item $P=\mathtt{(builtin}\ b \mathtt{)}$ is always well-formed.
\item $P=\mathtt{(force}\ P^{\prime}\mathtt{)}$ is well-formed if $P^{\prime}$ is well-formed and $\iota \in \QVar$.
\item $P=\mathtt{[}P^{\prime}\ V\mathtt{]}$ is well-formed if $P^{\prime}$ is
  well-formed and $V \sim \iota$ (see Figure~\ref{fig:compatibility} for the
  definition of $\sim$).
\item Furthermore, if $l = n$ then we require that built-in polymorphic types
  are used consistently in $P$.
\end{enumerate}

\kwxm{Note that apart from type names all of this stuff is meta-notation that is
  need to describe the builtins machinery but isn't part of the language.}

\noindent Conditions (2) and (3) say the arguments of $b$ are properly
interleaved with occurrences of \texttt{force}, and that the arguments are of
the expected types.  For type consistency, the compatibility condition says that
(a) if the signature specifies a monomorphic built-in type then the type of $V$
must match it exactly; (b) if the signature specifies a polymorphic built-in
type then $V$ must be a constant of \textit{some} built-in type; and (c) if the
signature specifies a full-polymorphic type then any input is acceptable.

In case (b) further checks will be required if and when $b$ becomes fully
applied, to make sure that polymorphic type variables are instantiated
consistently.

\paragraph{Consistency of arguments and signatures.}
The meaning of condition (4) should be fairly obvious; for example if we have a
builtin $b$ with signature $[\forall a_\#, \forall b_\#, a_\#, \listOf{a_\#},
  \pairOf{a_\#}{b_\#}] \rightarrow \pairOf{\listOf{a_\#}}{\listOf{b_\#}}$ then
in a well-formed saturated application \texttt{[(builtin $b$) $U$ $V$ $W$]}
there must be (monomorphic) types $t, u \in \Uni$ such that $U$ is a constant of
type $t$, $V$ is a constant of type $\listOf{t}$, and $W$ is a constant of type
$\pairOf{t}{u}$.  A full definition of consistency will be added in a subsequent
version of this document.  We will define consistency to be a binary relation
$\approx$ between lists of values and reduced arities and we will use this
notation later in the document even though the full definition is not available yet.
\kwxm{Presumably this is some standard unification thing, but I haven't pinned that down yet.}
\kwxm{In fact the machinery is a bit laxer than this.  If we have
  \texttt{[(builtin modInteger) (con string "x")]} then that will fail
  immediately (in the evaluator), but for polymorphic builtins the consistency
  check doesn't happen until we get into the definition of the builtin, and it's
  up to the implementation to do the check (cf \texttt{mkCons}).  It's
  conceivable that a builtin might \textit{not} check for consistency: for
  instance I think we could have a builtin with signature
  $[\forall a_\#, a_\#, a_\#] \rightarrow a_\#$
  which would just throw away its second argument and
  return the first without ever checking the types.  Note also that no
  consistency checking can happen (with the current implementation) until we
  have all the arguments.  If we had a builtin with signature
  $[\forall a_\#, a_\#, a_\#, \texttt{integer}] \rightarrow a_\#$
  (we don't have anything like this at the moment) then we could apply it to a
  boolean and a string and get a partial application which according to the
  current definition (and implementation) would be well-formed.}

  \kwxm{Maybe we could have a judgment $\mathsf{wf}$ and define it using inference rules?}

\noindent We can now complete the definition of values in Figure~\ref{fig:untyped-cek-values}
by defining $A$ to be the set of well-formed \textit{partial} built-in function applications
$$
A = \{P \in \textsf{P}: P \mbox{ is well-formed and } \length(P) < \left|\alpha(\beta(P))\right|\}
$$

