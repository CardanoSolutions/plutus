\section{Term Reduction}
\label{sec:reduction}

\kwxm{
  What can happen when we have \texttt{[((builtin $b$ ...) $V$]} (maybe
interleaved with some forces) with $\iota$ the head of the remaining $\alpha$
(ie $\iota$ tells you the what the next thing $b$'s expecting is)?


Since $\iota \in \UnihatStar \disj \QVar$ there are four possibilities:
\begin{itemize}
\item $\iota \in \Unihat$.  Then there are two possibilities:
  \begin{itemize}
    \item $\iota \in \Uni$.  Then $\iota$ is a monomorphic built-in type and we expect $V$ to
    have exactly that type.  So $V$ must lie in $\Con{\iota}$, and we fail immediately if it doesn't
  \item $\iota \in \Unihat \backslash \Uni$.  Then $\iota$ is a polymorphic built-in type, so
    we check that $V$ lies in \textit{some} $\Con{tn}$: if it does then we continue, deferring
    full type checks until the application becomes saturated; if it doesn't, we fail.
  \end{itemize}
\item $\iota \in \Var_*$.  Any term is acceptable, no matter what its type, so we carry on regardless.
\item $\iota \in \QVar$. In this case a \texttt{force} is expected, so we fail.
\end{itemize}
The semantics and the evaluator both have to deal with all of these cases, which makes things
quite complex.
}


This section defines the semantics of (untyped) Plutus Core.

\input{untyped-values.tex}


\paragraph{More notation.} Suppose that $A$ is a well-formed partial application with
$\beta(A) = b$, $\alpha(b) = [\iota_1,\ldots,\iota_n]$, and $\length(A) = l$.
We define a function $\nextArg$ which extracts the next argument (or
\texttt{force}) expected by $A$:
$$
    \nextArg(A) = \iota_{l+1}
$$
\noindent
This makes sense because in a well-formed partial application we have $l<n$.

\medskip
\noindent We also define a function $\args{}$ which extracts the arguments which
$b$ has received so far in $A$:
$$
\begin{array}{ll}
  \args(\builtin{b}) &= []\\
  \args(\appU{A}{V}) &= (\args(A))\snoc V\\
  \args(\force{A})   &= \args(A)\\
\end{array}
$$

\subsection{Term reduction}

%% ---------------- Grammar of Reduction Frames ---------------- %%
\kwxm{Explain what this stuff means. Remember that when we apply the reduction
  rules we always use the first applicable one.

  I'm somewhat tempted to dump this in favour of SOS.}
\kwxm{Do we need a uniqueness condition on names somewhere?}
    
\kwxm{I'm not entirely confident about these rules, especially the third rule
  (for unsaturated builtin application).  This is rather confusing because the
  first \texttt{[$A$ $V$]} is a frame \texttt{[$A$ \_]} containing a $V$ and the
  second one is a value.  The value is guaranteed to be well formed because $A$
  is by definition (maybe we should call these $W$ or something to make it
  clearer that they only represent \textit{well-formed} partial applications)
  and the premises ensure that \texttt{[$A$ $V$]} is too.  I'm still not
  convinced though.  If we have \texttt{[(builtin addInteger) (con string "x")]}
  then that's illegal but I think we won't see that because we're only supposed
  to look at the frame \texttt{[$V$ \_]} when the hole is filled with a redex,
  and \texttt{(con string "x")} isn't a redex.}

We define the semantics of Plutus Core using contextual semantics (or reduction
semantics): see~\cite{Felleisen-Hieb} or~\cite[5.3]{Harper:PFPL}, for example.
We use $A$ to denote a partial application of a built-in function as in
Section~\ref{sec:uplc-values} above.  For builtin evaluation, we
instantiate the set $\Inputs$ of Section~\ref{sec:builtin-inputs} to be the set
of Plutus Core values.  Thus all builtins take values as arguments and return a
value or $\errorX$.  Since values are terms here, we can take $\reify{V} = V$.
\kwxm{Eh?}

\newcommand\Eval[2]{\mathsf{Eval}\,(#1,#2)}

\begin{figure}[H]
\begin{subfigure}[c]{\linewidth}
    \centering
    \[\begin{array}{lrclr}
        \textrm{Frame} & f  & ::=   & \inAppLeftFrame{M}          & \textrm{left application}\\
                       &   &     & \inAppRightFrame{V}            & \textrm{right application}\\
                       &   &     & \inForceFrame                  & \textrm{force}
    \end{array}\]
    \caption{Grammar of reduction frames for Plutus Core}
    \label{fig:untyped-reduction-frames}
\end{subfigure}
%\end{figure}

\bigskip
%\begin{figure}[H]
%\ContinuedFloat
%% ---------------- Reduction via Contextual Semantics ---------------- %%
\begin{subfigure}[c]{\linewidth}
  % \def\labelSpacing{20pt}

  \judgmentdef{$\step{M}{M'}$}{Term $M$ reduces in one step to term $M'$.}

   % [(lam x M) V] -> [V/x]M
    \begin{prooftree}
        \AxiomC{}
        % \RightLabel{\textsf{apply-lambda}}
        \UnaryInfC{$\step{\app{\lamU{x}{M}}{V}}{\subst{V}{x}{M}}$}
    \end{prooftree}

    % [A V] saturated
    \begin{prooftree}
      \AxiomC{$\length(A) = \left|\beta(\alpha(A))\right|-1$}
      \AxiomC{$V \sim \nextArg(A)$}
        % \RightLabel{\textsf{final-apply}}
        \BinaryInfC{$\step{\app{A}{V}}{\Eval{\beta(A)}{(\args(A))\snoc V}}$}
    \end{prooftree}

    % [A V] unsaturated
    \begin{prooftree}
      \AxiomC{$\length(A) < \left|\beta(\alpha(A))\right|-1$}
      \AxiomC{$V \sim \nextArg(A)$}
        % \RightLabel{\textsf{intermediate-apply}}
        \BinaryInfC{$\step{\app{A}{V}}{\app{A}{V}}$}
    \end{prooftree}

    % force (delay M) -> M
    \begin{prooftree}
        \AxiomC{}
        % \RightLabel{\textsf{force-delay}}
        \UnaryInfC{$\step{\force{\delay{M}}}{M}$}
    \end{prooftree}

    % Saturated force
    \begin{prooftree}
      \AxiomC{$\length(A) = \left|\beta(\alpha(A))\right|-1$}
      \AxiomC{$\nextArg(A) \in \QVar$}
        % \RightLabel{\textsf{final-force}}
        \BinaryInfC{$\step{\force{A}}{\Eval{\beta(A)}{\args(A)}}$}
    \end{prooftree}


    % Unsaturated force
    \begin{prooftree}
      \AxiomC{$\length(A) < \left|\beta(\alpha(A))\right|-1$}
      \AxiomC{$\nextArg(A) \in \QVar$}
        % \RightLabel{\textsf{intermediate-force}}
        \BinaryInfC{$\step{\force{A}}{A}$}
    \end{prooftree}

%    \hfill\begin{minipage}{0.3\linewidth}  
      \begin{prooftree}
        \AxiomC{} % If we're putting these side by side we need \strut here to get rules aligned
        % \RightLabel{\textsf{error}}
        \UnaryInfC{$\step{\ctxsubst{f}{\errorU}}{\errorU}$}
      \end{prooftree}
%    \end{minipage}
%    \begin{minipage}{0.3\linewidth}
    \begin{prooftree}
        \AxiomC{$\step{M}{M'}$}  % Need \strut for side-by-side alignment again
        \UnaryInfC{$\step{\ctxsubst{f}{M}}{\ctxsubst{f}{M'}}$}
    \end{prooftree}
% \end{minipage}\hfill\hfill %% Don't know why we need two \hfills here but only one at the start
% \\
    \caption{Reduction via Contextual Semantics} %% Oops
    \label{fig:untyped-reduction}
\end{subfigure}

\bigskip

\begin{subfigure}[c]{\linewidth}
$$ \mathsf{Eval}(b, [V_1, \ldots, V_n]) \equiv \left\{
   \begin{array}{ll}
      \errorU  & \mbox{if $\denote{b}(\denote{V_1}, \ldots, \denote{V_n})= \errorX$}\\  
      \reify{\denote{b}(\denote{V_1}, \ldots, \denote{V_n})} & \mbox{otherwise}
   \end{array}
   \right. \\
$$
    \caption{Built-in function application}
    \label{fig:bif-appl}
\end{subfigure}

\caption{Term reduction for Plutus Core}
\label{fig:untyped-term-reduction}
\end{figure}

\bigskip
\noindent It can be shown that any closed Plutus Core term whose evaluation terminates
yields either \texttt{(error)} or a value.

\kwxm{I was worried because we only have rules for eg application of a builtin
  $b$ to a final argument, and when we're applying $b$ to other arguments we
  don't check that a term argument is actually expected (rather than a
  \texttt{force}), and that the argument has the right type.  I think this is OK
  though: for example, if we have a builtin $b$ with $\arity{b} = [\forall a_\#,
    \texttt{int}]$ and we have a term $M = \texttt{[(builtin b) (con 5)]}$ then
  none of the rules apply because $M$ isn't in $A$, so the semantics get stuck.
  This happens in general as well: the definition of $A$ doesn't even let us
  talk about partial builtin applications where the interleaving is wrong.  We
  \textit{do} need special rules for the final argument because if $M \in A$ we
  have to look at $b$ to make sure that the final argument (or force) is the
  right kind of thing.}
  
  
