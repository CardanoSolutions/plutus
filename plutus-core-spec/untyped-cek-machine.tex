\section{The CEK machine}
This section contains a description of an abstract machine for efficiently
executing Plutus Core.  This is based on the CEK machine of Felleisen and
Friedman~\citep{Felleisen-CK-CEK}.

\noindent The machine alternates between two main phases: the
\textit{compute} phase ($\triangleright$), where it recurses down
the AST looking for values, saving surrounding contexts as frames (or
\textit{reduction contexts}) on a stack as it goes; and the
\textit{return} phase ($\triangleleft$), where it has obtained a value and
pops a frame off the stack to tell it how to proceed next.  In
addition there is an error state $\cekerror$ which halts execution
with an error, and a halting state $\cekhalt{}$ which halts execution and
returns a value to the outside world.

To evaluate a program $\texttt{(program}\ v\ M \texttt{)}$, we first check that
the version number $v$ is valid, then start the machine in the state $[];[]
\triangleright M$.  It can be proved that the transitions in
Figure~\ref{fig:untyped-cek-machine} always preserve validity of states, so that
the machine can never enter a state such as $[] \triangleleft M$ or $s,
\texttt{(force \_)} \triangleleft \texttt{(lam}\ x\ A \ M\texttt{)}$ which isn't
covered by the rules.  If such a situation were to occur in an implementation
then it would indicate that the machine was incorrectly implemented or that it
was attempting to evaluate an ill-formed program (for example, one which attempts
to apply a variable to some other term).

\begin{figure}[H]
    \centering
    \[\begin{array}{lrclr}
        \textrm{Stack} & s      & ::= & f^*\\
        \textrm{CEK value} & V &  ::= & \VCon{tn}{c} \enspace | \enspace \VDelay{M}{\rho}
               \enspace| \enspace \VLamAbs{x}{M}{\rho} \enspace | \enspace \VBuiltin{b}{\repetition{V}}{\varepsilon}\\
        \textrm{Environment} & \rho & ::= & [] \enspace | \enspace \rho[x \mapsto V] \\
        \textrm{State} & \Sigma & ::= & s;\rho \compute M \enspace | \enspace s \return V  \enspace | \enspace \cekerror{} \enspace | \enspace \cekhalt{V}\\
        \textrm{Expected builtin arguments} & \varepsilon & ::= & [\iota] \enspace | \enspace \iota::\varepsilon\\
    \end{array}\] 
    \caption{Grammar of CEK machine states for Plutus Core}
    \label{fig:untyped-cek-states}
\end{figure}
\kwxm{$\varepsilon$ is the same as $\alpha$ except that we require it to be
  nonempty syntactically, whereas we put extra conditions on $\alpha$ in the
  definition of arities for builtins that make $\alpha(b)$ nonempty for all $b
  \in \Fun$.  This means that we can never have an empty $\varepsilon$ in
  $\VBuiltin{b}{\repetition{V}}{\varepsilon}$, which isn't entirely obvious.
  We'll be in trouble here if we ever have nullary builtins.}
  
\kwxm{Do we need to insist that CEK-values are well-formed, for example that
  there are enough variables in the environments to yield closed terms and that
  in $\VBuiltin{b}{\repetition{V}}{\varepsilon}$ $\varepsilon$ is a suffix of $\arity{b}$?
  Presumably the answer is no: you'd hope that a closed (and well-formed?) term
  $M$ will always yield a well-formed CEK value.}

\begin{figure}
    \centering
    \[\begin{array}{lrclr}
        \textrm{Frame} & f  & ::=   & \inForceFrame              & \textrm{force}\\
                       &    &       & \inAppLeftFrame{(M,\rho)}  & \textrm{left application}\\
                       &    &       & \inAppRightFrame{V}        & \textrm{right application}

    \end{array}\]
    \caption{Grammar of reduction frames for Plutus Core}
    \label{fig:untyped-cek-reduction-frames}
\end{figure}

Figures~\ref{fig:untyped-cek-states} and \ref{fig:untyped-cek-reduction-frames}
define some notation for \textit{states} of the CEK machine: these involve a
modified type of value adapted to the CEK machine, enivronments which bind names
to values, and a stack which stores partially evaluated terms whose evaluation
cannot proceed until some more computation has been performed (for example,
since Plutus Core is a strict language function arguments have to be reduced to
values before application takes place, and because of this a lambda term may
have to be stored on the stack while its argument is being reduced to a value).
Environments are lists of the form $\rho = [x_1 \mapsto V_1, \ldots, x_n \mapsto
  V_n]$ which grow by having new entries appended on the right; we say that
\textit{$x$ is \textit{bound} in the environment $\rho$} if $\rho$ contains an
entry of the form $x \mapsto V$, and in that case we denote by $\rho[x]$ the
value $V$ in the rightmost (ie, most recent) such entry.

To make the CEK machine fit into the built-in evaluation mechanism defined in
Section~\ref{sec:specify-builtins} we define $\Inputs = V$ and $\Con{\tn} =
\{\VCon{tn}{c} : \tn \in \Uni, c \in \denote{\tn}\}$.

The rules in Figure~\ref{fig:untyped-cek-machine} show the transitions of the
machine; if any situation arises which is not included in these transitions (for
example, if a frame $\inAppRightFrame{\VCon{tn}{c}}$ is encountered or if an
attempt is made to apply \texttt{force} to a partial builtin application which
is expecting a term argument), then the machine stops immediately in an error
state.


% Allow page break for (slightly) better placement
\begin{figure}[H]
  \begin{subfigure}[c]{\linewidth}
    \judgmentdef{$\Sigma \mapsto \Sigma^{\prime}$}{Machine takes one step from state $\Sigma$ to state $\Sigma'$}

%\hspace{-1cm}
    \begin{minipage}{\linewidth}
\begin{alignat*}{2}
 s;\rho & \compute x                                 &~\mapsto~& s \return  \rho[x] \enskip \mbox{if $x$ is bound in $\rho$}\\
 s;\rho & \compute \con{tn}{c}                       &~\mapsto~& s \return \VCon{tn}{c}\\
 s;\rho & \compute \lamU{x}{M}                       &~\mapsto~& s \return \VLamAbs{x}{M}{\rho}\\
 s;\rho & \compute \delay{M}                         &~\mapsto~& s\return \VDelay{M}{\rho}\\
 s;\rho & \compute \force{M}                         &~\mapsto~& \inForceFrame{} \cons s;\rho \compute M \\
 s;\rho & \compute \appU{M}{N}                       &~\mapsto~& \inAppLeftFrame{(N,\rho)} \cons s ;\rho \compute M\\
% No nullary builtins (yet)
 s;\rho & \compute \builtin{b}                      &~\mapsto~& s \return \VBuiltin{b}{[]}{\arity{b}}\\
 s;\rho & \compute \errorU                           &~\mapsto~& \cekerror{}\\
\\[-10pt] %% Put some vertical space between compute and return rules, but not a whole line
[] & \return V                                    &~\mapsto~& \cekhalt{V}\\
\inAppLeftFrame{(M,\rho)}  \cons s            & \return V  &~\mapsto~& \inAppRightFrame{V} \cons s;\rho \compute M\\
\inAppRightFrame{\VLamAbs{x}{M}{\rho}} \cons s   & \return V  &~\mapsto~& s;\rho[x \mapsto V] \compute M\\
\inForceFrame{} \cons s & \return \VDelay{M}{\rho}         &~\mapsto~& s;\rho \compute M\\
\inForceFrame{} \cons s & \return \VBuiltin{b}{\repetition{V}}{(\iota \cons \varepsilon)} &~\mapsto~&
                         s \return \VBuiltin{b}{\repetition{V}}{\varepsilon} \enskip \mbox{if $\iota \in \QVar$}\\
\inForceFrame{} \cons s & \return \VBuiltin{b}{\repetition{V}}{[\iota]}   &~\mapsto~&
                         \mathsf{Eval}\,(s, b, \repetition{V}) \enskip \mbox{if $\iota \in \QVar$}\\
\inAppRightFrame{\VBuiltin{b}{\repetition{V}}{(\iota \cons \varepsilon)}} \cons s & \return V &~\mapsto~&
                         s \return \VBuiltin{b}{(\repetition{V} \snoc V)}{\varepsilon} \enskip \mbox{if $V \sim \iota$}\\
\inAppRightFrame{\VBuiltin{b}{\repetition{V}}{[\iota]}} \cons s  & \return V &~\mapsto~&
                         \mathsf{Eval}\,(s, b, \repetition{V}\snoc V) \enskip \mbox{if $V \sim \iota$}\\
\end{alignat*}
\end{minipage}
    \caption{CEK machine transitions for Plutus Core}
    \label{fig:untyped-cek-transitions}
\end{subfigure}

\bigskip
  \begin{subfigure}[c]{\linewidth}
$$ \mathsf{Eval}(s, b, [V_1, \ldots, V_n]) \equiv \left\{
   \begin{array}{ll}
      \cekerror  & \mbox{if $[V_1, \ldots, V_n] \not\approx \bar{\alpha}(b)$}\\  
      \cekerror  & \mbox{if $\denote{b}(\denote{V_1}, \ldots, \denote{V_n})= \errorX$}\\  
      s \return \reify{\denote{b}(\denote{V_1}, \ldots, \denote{V_n})} & \mbox{otherwise}
   \end{array}
   \right. \\
$$
    \caption{Evaluation of built-in functions}
    \label{fig:untyped-cek-builtins}
    \end{subfigure}

  \caption{A CEK machine for Plutus Core}
\label{fig:untyped-cek-machine}
\end{figure}

\kwxm{The first $\cekerror$ case in the definition of \textsf{Eval} says that the machine
  should halt (before we even start to evaluate $b$) if \#-variables are not
  instantiated consistently as required by the signature of $b$ and the second
  case says that the machine should halt if we do call $b$ but it returns
  $\errorX$ due to some internal failure.}
