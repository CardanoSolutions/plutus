\section{Interpretation of built-in types and functions.}
\label{sec:specify-builtins}
As mentioned earlier, Plutus Core is generic over a universe $\Uni$ of types and
a set $\Fun$ of built-in functions.  As the terminology suggests, built-in
functions are interpreted as functions over terms and elements of the built-in
types: in this section we make this interpretation precise by giving a
specification of built-in types and functions in a set-theoretic denotational
style.  We require a considerable amount of extra notation in order to do this,
and we emphasise that nothing in this section is part of the syntax of Plutus
Core: it is meta-notation introduced purely for specification purposes.


\paragraph{Set-theoretic notation.}
We begin with some extra set-theoretic notation:
\begin{itemize}
  \item $\N = \{0,1,2,3,\ldots\}$.
  \item $\Nplus = \{1,2,3,\ldots\}$.
  \item $\Z = \{\ldots, -2, -1, 0, 1, 2, \ldots\}$
  \item $\byte = \{n \in \Z: 0 \leq n \leq 255\}$, the set of 8-bit bytes.
\item The symbol $\disj$ denotes a disjoint union of sets;  for emphasis we often use this
  to denote the union of sets which we know to be disjoint.
\item Given a set $X$, $X^*$ denotes the set of finite sequences of elements of
  $X$:
$$
  X^*= \bigdisj{\{X^n: n \in \mathbb{N}\}}.
  $$
  \kwxm{This is conflated with the list notation introduced earlier, but I don't think we say that anywhere.}
\item We assume that there is a special symbol $\errorX$ which does not appear
  in any other set we mention.  The symbol $\errorX$ is used to indicate that
  some sort of error condition has occurred, and we will often need to consider
  situations in which a value is either $\errorX$ or a member of some set $S$.
  For brevity, if $S$ is a set then we define
      $$
      \withError{S} := S \disj \{\errorX\}.
      $$
\end{itemize}

\subsection{Built-in types}
\label{sec:built-in-types}
We require some extra syntactic notation for built-in types: see Figure~\ref{fig:type-names-operators}.

\begin{minipage}{\linewidth}
    \centering
    \[\begin{array}{rclr}
    \mathit{atn}    & ::= & n & \textrm{Atomic type}\\
     op             & ::= & n & \textrm{Type operator}\\
     tn             & ::= & \mathit{atn} \ | \ op(tn,tn,...,tn) & \textrm{Type}\\
    \end{array}\]
    \captionof{figure}{Type names and operators}
    \label{fig:type-names-operators}
\end{minipage}

\medskip
\noindent
We assume that we have a set $\Uni_0$ of \textit{atomic type names} and a set
$\TyOp$ of \textit{type operator names}.  Each type operator name $\op \in
\TyOp$ has an \textit{argument count} $\valency{\op} \in \Nplus$, and a type name
$\op(tn_1, \ldots, \tn_n)$ is well-formed if and only if $n = \valency{\op}$.
We define the \textit{universe} $\Uni$ to be the closure of $\Uni_0$ under repeated
applications of operators in $\TyOp$:
$$
\Uni_{i+1} = \Uni_i \cup \{\op(tn_1, \ldots, tn_{\valency{\op}}): \op \in \TyOp, tn_1, \ldots, tn_{\valency{op}} \in \Uni_i\}
$$
$$
\Uni = \bigcup\{\Uni_i: i \in \Nplus\}
$$

\kwxm{Maybe we could have a judgment like $\Uni \vdash t\ \textsf{type}$
  and use inference rules instead of sets.  That would amount to the same thing but
would be considerably less compact.}

\kwxm{I'm inconsistently using ``type'' and ``type name'' for the things in
  $\Uni$, and that's further complicated by the introduction of polymorphic types later.}

The universe $\Uni$ consists entirely of \textit{names}, and the semantics of
these names are given by \textit{denotations}. Each type name $\tn \in \Uni$ is
associated with some mathematical set $\denote{tn}$, the \textit{denotation} of
$\tn$. For example, we might have $\denote{\texttt{boolean}}= \{\mathsf{true},
\mathsf{false}\}$ and $\denote{\texttt{integer}} = \mathbb{Z}$ and
$\denote{\pairOf{a}{b}} = \denote{a} \times \denote{b}$.  See
Appendix~\ref{appendix:default-builtins-alonzo} for a description of the built-in
types and type operators available in The Alonzo release of Plutus Core.

For non-atomic type names $tn = \op(tn_1, \ldots, \tn_r)$ we require the
denotation of $tn$ to be obtained in some uniform way from the denotations of
$tn_1, \ldots, \tn_r$.  
\kwxm{The thing about denotations of non-atomic type names being obtained in
  ``in some uniform way'' from the argument types is more than a little bit
  vague.}

\subsubsection{Type Variables}
Built-in functions can be polymorphic, and to deal with this we need
\textit{type variables}.  An argument of a polymorphic function can be either
restricted to built-in types or can be an arbitrary term, and we define two
different kinds of type variables to cover these two situations.  See
Figure~\ref{fig:type-variables}, where we also define a class of
\textit{quantifications} which are used to introduce type variables.

\begin{minipage}{\linewidth}
  \centering
      \[\begin{array}{lrclr}
        \textrm{TypeVariable}    & tv      & ::= & n_{*} & \textrm{fully polymorphic type variable}\\
                                 &         &     & n_{\#} & \textrm{built-in-polymorphic type variable}\\
        \textrm{Quantification}  & q       & ::= & \forallty{tv} & \textrm{quantification}\\
        
    \end{array}\]
    \captionof{figure}{Type variables}
    \label{fig:type-variables}
\end{minipage}

\medskip
\noindent
We denote the set of all possbile quantifications by $\QVar$, the set of all
possible type variables by $\Var$, the set of all fully-polymorphic type
variables by $\Var_*$, and the set of all built-in-polymorphic type variables
$v_\#$by $\Var_\#$.  Note that $\Var \cup \Uni = \varnothing$ since the symbols
${}_*$ and ${}_\#$ do not occur in $\Uni$.

The two kinds of type variable are required because we have two different types
of polymorphism. Later on we will see that built-in functions can take arguments
which can be of a type which is unknown but must be in $\Uni$, whereas other
arguments can range over a larger set of values such as the set of all Plutus
Core terms. Type variables in $\Var_\#$ are used in the former situation
and $\Var_*$ in the latter.

Given a variable $v \in \Var$ we sometimes write
$$
   \kindhash{v} \mbox{\quad if $v \in \Var_\#$}
$$
and
$$
   \kindstar{v} \mbox{\quad if $v \in \Var_*$}
$$

\kwxm{I'm using syntax to represent kinds here.  I haven't introduced actual
  kinds because (a) we don't have a proper type system in Plutus Core (yet), and
  (b) the \texttt{TypeScheme} type in the implementation only has one kind of
  type variable.  I'm only using this in the specification of the signatures of
  built-in functions to characterise some aspects how the builtins machinery
  works in practice: things in $\Var_*\backslash\Var_\#$ can fail with an
  unlifting error at runtime but that's not statically enforced anywhere.}
\kwxm{The $::$ notation risks confusion with the list cons notation.}
We also need to talk about polymorphic types, and to do this we define an
extended universe of types $\Unihat$ by adjoining $\Var_\#$ to $\Uni_0$ and
closing under type operators as before:

$$
\Unihat_0 = \Uni_0 \cup \Var_\#
$$
$$
\Unihat_{i+1} = \Unihat_i \cup \{\op(tn_1, \ldots, tn_{\valency{\op}}): \op \in \TyOp, tn_1, \ldots, tn_{\valency{op}} \in \Unihat_i\}
$$
$$
\Unihat = \bigcup\{\Unihat_i: i \in \Nplus\}
$$

\noindent We define the set of \textit{free variables} of an element of $\Unihat$ by
$$
\fv{tn} = \varnothing \ \mbox{if $tn \in \Uni_0$}
$$
$$
\fv{v_\#} = \{v_\#\}
$$
$$
\fv{\op(tn_1, \ldots, tn_k)} = \fv{tn_1} \cup \fv{tn_2} \cup \cdots \cup \fv{tn_r}
$$
  
\noindent Thus $\fv{tn} \subseteq \Var_\#$ for all $tn \in \Uni$.
We say that a type name $tn \in \Unihat$ is \textit{monomorphic} if $\fv{tn} =
\varnothing$; otherwise $tn$ is \textit{polymorphic}.  The fact that type variables
in $\Unihat$ are only allowed to come from $\Var_\#$ will ensure that values of
polymorphic types such as lists and pairs can only contain values of built-in
types: in particular, we will not be able to construct types representing things
such as lists of Plutus Core terms.

\kwxm{For type operators, ``polymorphic'' really means ``polymorphic over
  built-in types''.}

\kwxm{$\Uni$ is the set of built-in types and $\Unihat$ is
  that set extended to include polymorphic types as well.  Later on we quite
  often have to look at $\Unihat\backslash \Uni$ to talk about types that really
  are polymorphic. Maybe it would be better to have a separate universe of
  polymorphic types called $\Uni_{\#}$ or something, but then we'd also have to
  talk about $\Uni \disj \Uni_{\#}$ instead.  Maybe we could define $\Unihat =
  \Uni \disj \Uni_{\#}$?
  }

\subsection{Arguments of built-in functions}
\label{sec:builtin-inputs}
To treat the typed and untyped versions of Plutus Core uniformly it is necessary
to make the machinery of built-in functions generic over a set $\Inputs$ of
\textit{inputs} which are taken as arguments by built-in functions.  In practice
$\Inputs$ will be the set of Plutus Core values or something very closely
related.

\indent We require $\Inputs$ to have the following properties:
\begin{itemize}
\item $\Inputs$ is disjoint from $\denote{\tn}$ for all $\tn \in \Uni$
\item We require disjoint subsets $\Con{\tn} \subseteq \Inputs$ ($\tn \in \Uni$)
  of \textit{constants of type $\tn$} and maps $\denote{\cdot}_{\tn}: \Con{\tn}
  \rightarrow \denote{\tn}$ (\textit{denotation}) and $\reify{\cdot}_{\tn}:
  \denote{\tn} \rightarrow \Con{\tn}$ (\textit{reification}) such that
  $\reify{\denote{c}_{\tn}}_{\tn} = c \mbox{ for all } c \in \Con{\tn}$.  We do
  not require these maps to be bijective (for example, there may be multiple
  inputs with the same denotation), but the condition implies that
  $\denote{\cdot}_{\tn}$ is surjective and $\reify{\cdot}_{\tn}$ is injective.
\end{itemize}

\kwxm{I'm still not sure what to call the things what we feed to builtins.
  Previously there were called ``terms'', but in our setting they're \textit{not}
  actually arbitrary terms.  I tried ``values'' instead, but that was confusing.
  ``Inputs'' is a bit better, but (a) they're also what builtins
  \textit{output}, and (b) there's a small risk of confusion with UTXO inputs.}

\noindent For example, we could take $\Inputs$ to be the set of all Plutus Core
values (see Section~\ref{sec:uplc-values}), $\Con{\tn}$ to be the set of all
terms $\con{tn}{c}$, and $\denote{\cdot}_{\tn}$ to be the function which maps
$\con{tn}{c}$ to $c$.  For simplicity we are assuming that mathematical entities
occurring as members of type denotations $\denote{\tn}$ are embedded directly as
values $c$ in Plutus Core constant terms. In reality, tools which work with
Plutus Core will need some concrete syntactic representation of constants;
we do not specify this here, but see Section~\ref{sec:alonzo-built-in-types} for
suggested syntax for the built-in types included in the Alonzo release.

We will consistently use the symbol $\tau$ (and subscripted versions of it)
to denote a member of $\UnihatStar$ in the rest of the document.
\kwxm{Check that we really are doing that consistently.}


\subsection{Built-in functions}
\label{sec:builtin-functions}

\paragraph{Signatures.}
Every built-in function $b \in \Fun$ has a \textit{signature} $\sigma(b)$ of the form
$$[\iota_1, \ldots, \iota_n] \rightarrow \tau$$
with
\begin{itemize}
  \item $\iota_j \in \UnihatStar \disj \QVar \enspace\mbox{for all $j$}$
  \item $\tau \in \UnihatStar$
  \item $\lvert\{j : \iota_j \notin \QVar\}\rvert \geq 1$ (so $n \geq 1$)
  \item If $\iota_j$ involves $v \in \Var$ then $\iota_k = \forallty{v}$ for
    some $k < j$, and similarly for $\tau$; in other words, any type variable
    $v$ must be introduced by a quantification before it is used. (Here $\iota$
    \textit{involves} $v$ if either $\iota = tn \in \Unihat$ and $v \in \fv{tn}$
    or $\iota = v$ and $\kindstar{v}$.)
  \item If $j \neq k$ and $\iota_j, \iota_k \in \QVar$ then $\iota_j \neq
    \iota_k$; ie, no quantification appears more than once.
\end{itemize}
\noindent 


\noindent For example, in our default set of built-in functions we have the
functions \texttt{mkCons} with signature $[\forall a_\#, a_\#,
  \listOf{a_\#}] \rightarrow \listOf{a_\#}$ and \texttt{ifThenElse} with signature
$[\forall a_*, \mathtt{boolean}, a_*, a_*] \rightarrow a_*$.  When we use
\texttt{mkCons} its arguments must be of built-in types, but the two final
arguments of \texttt{ifThenElse} can be any Plutus Core values.

\kwxm{Can we write $\mathtt{mkPair}: [\forall a_\#, a_\#, \forall b_\#, b_\#] \rightarrow pair(a_\#,b_\#)$?}

\noindent If $b$ has signature $[\iota_1, \ldots, \iota_n] \rightarrow \tau$ then the \textit{arity}
of $b$ is
$$
  \alpha(b) = [\iota_1, \ldots, \iota_n]
$$
and the \textit{argument count} of $b$ is $\left|b\right| = n$
  

\noindent We may abuse notation slightly by using the symbol $\sigma$ to denote
a specific signature as well as the function which maps built-in function names
to signatures, and similarly with the symbol $\alpha$.

\medskip
\noindent Given a signature
$\sigma = [\iota_1, \ldots, \iota_n] \rightarrow \tau$,
we define the \textit{reduced signature} $\barsigma$ to be
$$
\barsigma = [\iota_j : \iota_j \notin \QVar] \rightarrow \tau
$$

We extend the usual set comprehension notation to lists in the obvious way, so
this just denotes the signature $\sigma$ with all quantifications omitted. We
will often write a reduced signature in the form $[\tau_1, \ldots, \tau_m]
\rightarrow \tau$ to emphasise that the entries are \textit{types}, and
$\mathbf{\forall}$ does not appear.

What is the intended meaning of this notation?  In Typed Plutus Core we have to
instantiate polymorphic functions (both built-in functions and polymorphic
lambda terms) at concrete types before they can be applied, and in Untyped
Plutus Core instantiation is replaced by an application of \texttt{force}.  When
we are applying a built-in function we supply its arguments one by one, and we
can also apply \texttt{force} (or perform type instantiation in the typed case)
to a partially-applied builtin ``between'' arguments (and also after the final
argument); no computation occurs until all arguments have been supplied and all
\texttt{force}s have been applied. The signature (read from left to right)
specifies what types of arguments are expected and how they should be
interleaved with applications of \texttt{force}. A fully-polymorphic type
variable $a_*$ indicates that an arbitrary value from $\Inputs$ can be provided,
whereas a type from $\Unihat$ indicates that a value of the specified built-in
type is expected. Occurrences of quantifications indicate that \texttt{force} is
to be applied to a partially-applied builtin; we allow this purely so that
partially-applied builtins can be treated in the same way as delayed
lambda-abstractions: \texttt{force} has no effect unless it is the very last
item in the signature).  In Plutus Core, partially-applied builtins are values
which can be treated like any others (for example, by being passed as an
argument to a \texttt{lam}-expression): see Section~\ref{sec:uplc-values}.

To make some of the above remarks more precise and simplify some of the later
exposition we introduce a relation $\sim \enspace \subseteq \Inputs \times
(\UnihatStar \disj \QVar)$ of \textit{compatibility} between inputs and
signature entries: this is defined in Figure~\ref{fig:compatibility}.

\begin{figure}[H]
  \centering
  $$
  \begin{array}{lll}
  V \sim \iota \enspace & \mbox{if} & \iota \in \Uni \mbox{ and $V \in \Con{\iota}$}\\
     & \mbox{or} & \iota \in \Unihat \backslash \Uni \\ %%\mbox{and $V \in \Con_{tn}$ for some $\tn \in \Uni$}\\
     & \mbox{or} & \iota \in \Var_*
  \end{array}
  $$
  \caption{Compatibility of inputs with signature entries}
  \label{fig:compatibility}
\end{figure}

\kwxm{This bit of notation really helps: I previously had to repeat the three
  cases in a number of places (in the CEK machine, for example).}

\noindent Note that we can never have $V \sim \forall v$.

\paragraph{Denotations of built-in functions.}
If we have a built-in function $b$ with reduced signature
$$
      \barsigma(b) = [\tau_1, \ldots, \tau_m] \rightarrow \tau,
$$

then we require $b$ to have a \textit{denotation} (or \textit{meaning}), a function
      
$$
\denote{b}: \denote{\tau_1} \times \cdots \times \denote{\tau_m} \rightarrow \withError{\denote{\tau}}
$$

\noindent where for a name $a$
$$
\denote{a_\#} = \bigdisj\{\denote{tn}: tn \in \Uni\}
$$
and
$$
\denote{a_*} = \Inputs.
$$


Denotations of builtins are mathematical functions which terminate on every
possible input; the symbol $\errorX$ can be returned by a function to indicate
that something has gone wrong, such as an attempted division by zero.

\medskip\noindent
If $r$ is the result of the evaluation of some built-in function there are thus
three possibilities:
\begin{enumerate}
\item $r \in \denote{\tn} \enspace \mbox{for some $\tn \in \Uni$}$
\item $r \in \Inputs$
\item $r = \errorX$
\end{enumerate}
In other words,
$$
r \in \R := \bigdisj\{\denote{\tn}: \tn \in \Uni \} \disj \Inputs \disj \{\errorX\}.
$$

\noindent Our assumptions on the set $\Inputs$
(Section~\ref{sec:builtin-inputs}) allow us define a function
$$
\reify{-}: \R \rightarrow \withError{\Inputs}
$$
which converts results of built-in functions back into inputs (or the $\errorX$ symbol)
\begin{enumerate}
\item If $r \in \denote{tn}$, then we let $\reify{r} = \reify{r}_{\tn} \in \Con{\tn} \subseteq \Inputs$.
\item If $r \in \Inputs$ then we let $\reify{r} = r$
\item We let $\reify{\errorX} = \errorX$
\end{enumerate}
\kwxm{We have to use $\Inputs \disj \{\errorX\}$ to deal with the fact that
  $\errorU$ isn't a value, so we have to defer handling errors until later.}
\kwxm{The notation here is maybe a bit confusing.  The $\Con{\tn}$ live in the
  syntactic world (where they're subsets of $\Inputs$) and the $\denote{tn}$
  live in the world of sets; however $\Inputs$ lives in \textit{both} worlds,
  and it's disjoint from all of the $\denote{tn}$ in the world of sets but not
  in the world of syntax.  I think we do need something like this because
  sometimes a builtin argument must be a constant but at other times it can be
  an arbitrary value, which includes all of the constants.}

\paragraph{Behaviour of built-in functions.}  
A built-in function $b$ can only inspect arguments which are values of built-in
types; other arguments (occurring as $a_*$ in $\barsigma(b)$) are treated opaquely,
and can be discarded or returned as (part of) a result, but cannot be altered or
examined (in particular, they cannot be compared for equality): $b$ is
\textit{parametrically polymorphic} in such arguments.  This implies that if a
builtin returns a value $v \in \Inputs$, then $v$ must have been an argument of
the function.

\roman{This is not quite true, unfortunately. \texttt{toBuiltinMeaning}
  constrains \texttt{term} with \texttt{HasConstantIn uni term}. This means that we can
  check whether an argument whose type is a type variable is a constant or
  not. And if it's a constant, we can obtain the type tag and do all kinds of
  fancy things with it. For example a builtin checking if two values of
  different types are equal constants is representable. This breaks parametricity.
}

\kwxm{I think we should just require that people don't do that. $\uparrow$}

\kwxm{I think we can express the parametricity property as follows.  Suppose $b$
  is a builtin with constant arguments $x_1,\ldots, x_m$ and ``term'' arguments
  $y_1, \ldots, y_n$.  Then there are two cases: (a) $b$ returns a constant, and
  (b) $b$ returns a term (you can tell which of these is true by looking at
  $\sigma(b)$).  In case (a), the result of applying $b$ should depend only on
  the values of the $x_i$ and be completely independent of the values of the
  $y_j$, and even of what $\Inputs$ is.  In case (b), for a given choice of the
  $x_i$, the output must be some $y_k$, and $k$ should be the same for all
  choices of $y_1, \ldots, y_n$, and again it should even be independent of the
  choice of $\Inputs$.}

We also require built-in functions to be parametrically polymorphic in arguments
which are of polymorphic built-in types, such as lists, and when a function
signature contains type variables in $\Var_\#$ we will expect the actual
arguments supplied during application to have consistent types (for a given type
variable $a_\#$, all arguments to which it refers should have the same built-in
type at run time).  However we do not enforce this in the notation above:
instead consistency conditions of this sort will be included in the
specifications of the semantics of the full Plutus Core language.

\kwxm{The thing about relegating consistent instantiation of
  built-in-polymorphic type variables to the full semantics is there because (a)
  it's non-trivial to specify, and (b) in fact it's not enforced by the builtin
  application machinery, but must be checked dynamically in the implementation
  of the builtin when it's fully applied (\texttt{mkCons} is an example of
  this). It would be perfectly possible (I think) to implement a builtin with
  signature $[\forall a_\#, a_\#, a_\#] \rightarrow a_\#$ which could be
  successfully applied to arguments of two different built-in types, returning a
  constant of a third type.  Let's assume that builtins always check this
  stuff.}
  
When (the meaning of) a built-in function $b$ is applied (perhaps partially) to
arguments, the types of constant arguments must correspond to the types in
$\barsigma(b)$, and the function will return $\errorX$ if this is not the
case; builtins may also return $\errorX$ in other circumstances, for example if
an argument is out of range.

\kwxm{A lot of the complexity we have here is due to the fact that we've got
  explicit \texttt{delay} and \texttt{force} instead of the usual $\lambda().M$
  and $M()$.  We use the explicit version because experiments showed that it was
  noticeably faster (and we have a lot of these due to erasure of type-level
  abstraction/instantiation).  Also, who's to say that the universe contains a
  unit type?
}

%% \begin{minipage}{\linewidth}
%%     \centering \[\begin{array}{llll}

%%     t & ::= & b   &\mbox{for } b \in \Uni  \\
%%     & & \typearg                 \\
%%     & & \star               \\
%%     & & t \rightarrow t          \\
%%     \end{array}\]
%% \end{minipage}

  

